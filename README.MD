###Todo
---
 * 解决canvas的半像素问题(尤其是边界的半像素太细)(2倍法)
 * 改用canvas实现后两个刻度尺接缝处没有对齐,要不短边用outline或利用小方块(宽高 29,右下border 1)来做吧!
 * 鼠标拖放手机,改变大小
 
 * 使用计算的方式得出画布内的元素(局部渲染)
 * 根据设计图完善细节
 * 把手机移到标尺旁会发现略有偏差,猜想是还是canvas的1px问题
 * 改变窗口大小时,canvas也应当重绘,否则:1.刻度变形 2.阴影与手机不对照
 * 加上 ±9999px的边界
 	** 在receiveProps处控制 ×
 	** 在事件分发处控制 √ 早处理可以避免不必要的通信代价//
 	** 控制边界条件时,很明显手机的宽度不是所需宽度(应该是窗口宽度,考虑把窗口也作为state,传入尺子
  				//,用于在外部控制尺子的宽高的同时,也方便在窗口resize时通过改变state的方式自动控制重绘
 * iphone div仅负责宽高,定位由它的父元素完成,这样可以省去不少计算的麻烦

###笔记
---
 * canvas
  * 1.垂直方向的刻度尺上的字体有些小麻烦,斟酌再三(css3旋转与canvas旋转),还是用canvas做了
    第一:css基于dom,效率远不如canvas
	第二:按照设计图中的文字方向,要么把css的旋转点设置在右下角,要么在z轴旋转的同时加上y轴翻转(显示背面)代码丑陋的同时不易扩展
  * 2.因为clearRect并不能清除路径,所以一定要注意beginpath和closepath,否则即使是用clearRect清除了画板,上一次未close的路径也将会被绘制出来
  * 3.网上说的乱七八糟,试验证明translate是相对移动,也就是说translate(0, 0)不是回原点,而是什么变换也不做,两次translate(10,10)相当于translate(20,20)
  * 4.在不用react-canvas的情况下,直接把canvas当做组件的一部分输出好像并没太大用(因为基本上每次交互都会造成canvas的重绘,而且根据props绘制的canvas元素并不能在props发生变化时自动reRender,还是要手动在WillReceiveProps里重绘)
  * 5. resize:both; overflow: auto; 可以使div可拖拽,可惜只能在原始尺寸的基础上放大,而不能缩小,并且只能在右下角操作,尝试着使用绝对定位 / readonly / 旋转的textarea小块做黑科技,但是结果不尽人意,还是老老实实监听鼠标事件吧 - -
 * React
  * onDrag在拖拽dom中的内容时触发(如文字)
  * 完成了鼠标拖动手机,改变位置
   * 监听需要拖拽区域的鼠标按下事件,以及document的鼠标移动和鼠标松开事件,因为如果鼠标移动过快,离开了拖拽区域才释放,就会出现各种奇怪的问题
###bug修复
---
  * 1.当移动一个方向时,另一个方向会稍微移动一下,应该还是canvas的1px问题,解决方法:
   * 在componentWillReceiveProps中为重绘加判断,只有当有属性改变时才重绘

